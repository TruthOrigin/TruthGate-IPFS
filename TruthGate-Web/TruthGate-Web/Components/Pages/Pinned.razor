@page "/pinned"
@using System.Text.Json
@using System.Text.Json.Serialization
@using MudBlazor
@using TruthGate_Web.Components.Pages.Settings.Shared
@using TruthGate_Web.Endpoints
@using TruthGate_Web.Utils
@inject IHttpClientFactory HttpFactory
@inject IDialogService Dialogs
@inject ISnackbar Snackbar
@inject IApiKeyProvider Keys
@rendermode InteractiveServer
@inject IJSRuntime JS

<MudContainer Class="py-3" MaxWidth="MaxWidth.Large">
    <div class="flex items-center justify-between mb-4">
        <MudText Typo="Typo.h3">Pinned Content</MudText>
        <br />
        <MudButton Variant="Variant.Filled"
        Color="Color.Primary"
        StartIcon="@Icons.Material.Filled.PushPin"
        OnClick="OnAddPinned">
            Add Pinned Item
        </MudButton>
    </div>

    <MudPaper Class="pa-4 mb-4">
        <MudText Typo="Typo.h6">Pinned Content Summary</MudText>
        <MudText>
            <b>@_items.Count()</b> pinned items are actively tracked and managed by TruthGate.
        </MudText>
        <MudText>
            <b>@_unmappedItems.Count()</b> pinned items were detected on this node but are not tracked by TruthGate.
        </MudText>
    </MudPaper>


    <MudTable Items="_items" Dense="true" Hover="true" Bordered="true" Loading="_loading">
        <ToolBarContent>
            <MudTextField @bind-Value="_search"
            Placeholder="Search by name or CID..."
            Adornment="Adornment.Start"
            AdornmentIcon="@Icons.Material.Filled.Search"
            Class="w-full md:w-96" />
            <MudSpacer />
            <MudButton Variant="Variant.Outlined" StartIcon="@Icons.Material.Filled.Refresh" OnClick="Reload">Refresh</MudButton>
        </ToolBarContent>

        <HeaderContent>
            <MudTh >Name</MudTh>
            <MudTh >CID</MudTh>
            <MudTh>Location</MudTh>
            <MudTh class="text-right">Size</MudTh>
            <MudTh>Actions</MudTh>
        </HeaderContent>

        <RowTemplate>
            <MudTd>
                @if (!string.IsNullOrWhiteSpace(context.Name))
                {
                    <MudText>@context.Name</MudText>
                    <MudText Typo="Typo.caption" Class="text-secondary">@context.MfsPath</MudText>
                }
                else
                {
                    <MudText Color="Color.Primary">—</MudText>
                }
            </MudTd>

            <MudTd>
                <MudStack Row="true">
                    <MudText Class="break-all truncate-text">@context.Cid</MudText>
                    <MudIconButton Icon="@Icons.Material.Filled.ContentCopy" Size="Size.Small" OnClick="@(() => Copy(context.Cid))" />
                </MudStack>
            </MudTd>

            <MudTd>
                @if (context.IsManaged)
                {
                    <MudChip T="string" Color="Color.Primary" Variant="Variant.Filled" Icon="@Icons.Material.Filled.Folder">/production/pinned</MudChip>
                }
                else if (context.IsProductionNonManaged)
                {
                    <MudTooltip Text="This pinned CID is under /production but not managed by /production/pinned. Deleting here is disabled.">
                        <MudChip T="string" Color="Color.Secondary" Variant="Variant.Filled" Icon="@Icons.Material.Filled.Error">/production (external)</MudChip>
                    </MudTooltip>
                }
                else
                {
                    <MudChip T="string" Color="Color.Default" Variant="Variant.Outlined" Icon="@Icons.Material.Filled.HelpOutline">unmapped</MudChip>
                }
            </MudTd>

            <MudTd Class="text-right">
                @if (context.SizeBytes is long b)
                {
                    <MudText>@FormatSize(b)</MudText>
                }
                else
                {
                    <MudText Color="Color.Primary">—</MudText>
                }
            </MudTd>

            <MudTd>
                @if (context.CanDelete)
                {
                    <MudButton Size="Size.Small"
                    Variant="Variant.Outlined"
                    Color="Color.Error"
                    StartIcon="@Icons.Material.Filled.DeleteForever"
                    OnClick="@(() => OnDelete(context))">
                        Delete
                    </MudButton>
                }
                else
                {
                    <MudTooltip Text="@(string.IsNullOrEmpty(context.DeleteDisabledReason)
                     ? "Deletion disabled"
                     : context.DeleteDisabledReason)">
                        <MudButton Size="Size.Small"
                        Variant="Variant.Outlined"
                        Disabled="true"
                        StartIcon="@Icons.Material.Filled.DeleteForever">
                            Delete
                        </MudButton>
                    </MudTooltip>
                }
            </MudTd>
        </RowTemplate>

        <NoRecordsContent>
            <MudText>No pinned items yet.</MudText>
        </NoRecordsContent>

        <PagerContent>
            <MudTablePager />
        </PagerContent>
    </MudTable>
</MudContainer>

@code {
    private bool _loading = true;
    private string? _search;
    private List<PinnedRow> _all = new();
    private IEnumerable<PinnedRow> _items => string.IsNullOrWhiteSpace(_search)
    ? _all.Where(x => !string.IsNullOrWhiteSpace(x.MfsPath))
    : _all.Where(x =>
        !string.IsNullOrWhiteSpace(x.MfsPath) &&
        (
            (!string.IsNullOrWhiteSpace(x.Name) && x.Name.Contains(_search, StringComparison.OrdinalIgnoreCase)) ||
             x.Cid.Contains(_search, StringComparison.OrdinalIgnoreCase)
        ));

    private IEnumerable<PinnedRow> _unmappedItems => string.IsNullOrWhiteSpace(_search)
    ? _all.Where(x => string.IsNullOrWhiteSpace(x.MfsPath))
    : _all.Where(x =>
    string.IsNullOrWhiteSpace(x.MfsPath) &&
    (
        (!string.IsNullOrWhiteSpace(x.Name) && x.Name.Contains(_search, StringComparison.OrdinalIgnoreCase)) ||
         x.Cid.Contains(_search, StringComparison.OrdinalIgnoreCase)
    ));


    private const string ProductionRoot = "/production";
    private const string ManagedRoot = "/production/pinned";

    protected override async Task OnInitializedAsync()
    {
        await Reload();
    }

    private async Task Reload()
    {
        try
        {
            _loading = true;

            // 1) Top-level recursive pins
            var pins = await ListRecursivePinsAsync();

            // 2) Snapshot immediate children maps
            var pinnedMap = await ListMfsChildrenAsync(ManagedRoot);

            // 2a) Normalize pinned map to v1 for O(1) lookup
            var pinnedByCidV1 = new Dictionary<string, (string Name, string Path)>(StringComparer.OrdinalIgnoreCase);
            foreach (var kv in pinnedMap)
            {
                var name = kv.Key;
                var (cid, _) = kv.Value;
                var cidV1Key = await NormalizeCidV1Async(cid);
                var path = IpfsGateway.NormalizeMfs($"{ManagedRoot}/{name}");
                // If duplicates somehow occur, keep the first
                if (!pinnedByCidV1.ContainsKey(cidV1Key))
                    pinnedByCidV1[cidV1Key] = (name, path);
            }

            // 2b) Build a CIDtopath index for /production and /production/*/*
            var prodIndex = await BuildProductionCidIndexAsync(); // already normalized to v1

            // 3) Build rows; try to map each pin
            var rows = new List<PinnedRow>(pins.Count);

            foreach (var rawCid in pins)
            {
                var cidV1 = await NormalizeCidV1Async(rawCid);

                string? mfsPath = null;
                string? name = null;
                bool isManaged = false;
                bool isProdOther = false;

                // A) Check /production/pinned direct children first (managed)
                if (pinnedByCidV1.TryGetValue(cidV1, out var pinnedHit))
                {
                    name = pinnedHit.Name;
                    mfsPath = pinnedHit.Path;
                    isManaged = true;
                }
                else
                {
                    // B) Check production index (covers immediate and first-level under /production/*)
                    if (prodIndex.TryGetValue(cidV1, out var entry))
                    {
                        name = entry.Name;
                        mfsPath = entry.Path;
                        isProdOther = !mfsPath.StartsWith(ManagedRoot, StringComparison.OrdinalIgnoreCase)
                                      && mfsPath.StartsWith(ProductionRoot, StringComparison.OrdinalIgnoreCase);
                    }
                }

                // Size: prefer MFS stat when we have a path; else DAG/Block stats
                long? size = null;
                if (!string.IsNullOrWhiteSpace(mfsPath))
                    size = await TryMfsCumulativeSizeAsync(mfsPath);
                if (size is null)
                    size = await TryDagSizeAsync(rawCid) ?? await TryBlockSizeAsync(rawCid);

                var canDelete = isManaged; // only managed entries deletable from this UI
                var reason = canDelete ? null :
                    (isProdOther
                        ? "Pinned under /production but not /production/pinned — likely used elsewhere."
                        : "Unmanaged pin — delete via node if you’re sure.");

                rows.Add(new PinnedRow
                    {
                        Cid = rawCid,
                        Name = name,
                        MfsPath = mfsPath,
                        IsManaged = isManaged,
                        IsProductionNonManaged = isProdOther,
                        SizeBytes = size,
                        CanDelete = canDelete,
                        DeleteDisabledReason = reason
                    });
            }

            _all = rows
                .OrderByDescending(r => r.IsManaged)
                .ThenBy(r => r.Name ?? r.Cid, StringComparer.OrdinalIgnoreCase)
                .ToList();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load pins: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loading = false;
            StateHasChanged();
        }
    }


    private async Task OnAddPinned()
    {
        var options = new DialogOptions
            {
                CloseOnEscapeKey = false,
                CloseButton = true,
                FullWidth = true,
                MaxWidth = MaxWidth.Medium
            };
        var parameters = new DialogParameters<AddPinnedItemDialog>();
        var dialog = Dialogs.Show<AddPinnedItemDialog>("Add Pinned Item", parameters, options);
        var result = await dialog.Result;

        if (result.Canceled || result.Data is not AddPinnedItemDialog.AddPinnedResult r) return;

        try
        {
            // Validate name uniqueness under /production/pinned (case-insensitive)
            var children = await ListMfsChildrenAsync(ManagedRoot);
            if (children.Keys.Any(k => string.Equals(k, r.Name, StringComparison.OrdinalIgnoreCase)))
            {
                Snackbar.Add($"A pinned item named '{r.Name}' already exists.", Severity.Error);
                return;
            }

            // Verify CID exists (will fetch/resolve if needed)
            if (!await VerifyCidExistsAsync(r.Cid))
            {
                Snackbar.Add("CID does not exist or cannot be resolved.", Severity.Error);
                return;
            }

            // Ensure parent exists
            await IpfsGateway.EnsureMfsFolderExistsAsync(ManagedRoot, HttpFactory);

            // Copy DAG into MFS at the desired leaf
            var dest = IpfsGateway.NormalizeMfs($"{ManagedRoot}/{r.Name}");
            await FilesCpFromIpfsAsync(r.Cid, dest);

            // Pin recursively
            await PinAddRecursiveAsync(r.Cid);

            Snackbar.Add($"Pinned '{r.Name}' to {r.Cid}", Severity.Success);
            await Reload();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to add pinned item: {ex.Message}", Severity.Error);
        }
    }

    private async Task OnDelete(PinnedRow row)
    {
        if (!row.CanDelete) return;

        var parameters = new DialogParameters<ConfirmDeleteDialog>
        {
            { x => x.Message, $"Unpin and delete '{(row.Name ?? row.Cid)}'?" }
        };
        var dialog = Dialogs.Show<ConfirmDeleteDialog>("Confirm Delete", parameters);
        var result = await dialog.Result;
        if (result.Canceled || result.Data is not bool ok || !ok) return;

        try
        {
            // Unpin recursive
            await PinRmRecursiveAsync(row.Cid);

            // Remove MFS entry if we have one (managed entries do)
            if (!string.IsNullOrWhiteSpace(row.MfsPath))
            {
                await FilesRmRecursiveAsync(row.MfsPath);
                // Targeted invalidation is handled by your cascade in Ensure/Rename flows.
                // Here we simply refresh the list.
            }

            Snackbar.Add($"Deleted pinned item '{(row.Name ?? row.Cid)}'.", Severity.Success);
            await Reload();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to delete: {ex.Message}", Severity.Error);
        }
    }

    private static string FormatSize(long bytes)
    {
        string[] units = ["B", "KB", "MB", "GB", "TB", "PB"];
        double v = bytes;
        int u = 0;
        while (v >= 1024 && u < units.Length - 1) { v /= 1024; u++; }
        return $"{v:0.##} {units[u]}";
    }

    // ---------------------------
    // Backend calls (via proxy)
    // ---------------------------

    private async Task<Dictionary<string, (string Cid, string Path)>> ListMfsChildrenAsync(string parentPath)
    {
        parentPath = IpfsGateway.NormalizeMfs(parentPath);
        var rest = $"/api/v0/files/ls?arg={Uri.EscapeDataString(parentPath)}&long=true";

        using var res = await ApiProxyEndpoints.SendProxyApiRequest(rest, HttpFactory, Keys);
        if (!res.IsSuccessStatusCode)
            return new(StringComparer.OrdinalIgnoreCase);

        var root = await ReadLastJsonObjectAsync(res);
        var dict = new Dictionary<string, (string Cid, string Path)>(StringComparer.OrdinalIgnoreCase);
        if (root is null) return dict;

        if (root.Value.TryGetProperty("Entries", out var entries) && entries.ValueKind == JsonValueKind.Array)
        {
            foreach (var e in entries.EnumerateArray())
            {
                var name = e.TryGetProperty("Name", out var n) ? n.GetString() ?? "" : "";
                var cid = e.TryGetProperty("Hash", out var h) ? h.GetString() ?? "" : "";
                if (!string.IsNullOrWhiteSpace(name) && !string.IsNullOrWhiteSpace(cid))
                {
                    var path = IpfsGateway.NormalizeMfs($"{parentPath}/{name}");
                    dict[name] = (cid, path);
                }
            }
        }
        return dict;
    }


    private async Task<List<string>> ListRecursivePinsAsync()
    {
        var rest = "/api/v0/pin/ls?type=recursive";
        using var res = await ApiProxyEndpoints.SendProxyApiRequest(rest, HttpFactory, Keys);
        if (!res.IsSuccessStatusCode) return new();

        var root = await ReadLastJsonObjectAsync(res);
        if (root is null) return new();

        var list = new List<string>();
        if (root.Value.TryGetProperty("Keys", out var keys) && keys.ValueKind == JsonValueKind.Object)
        {
            foreach (var prop in keys.EnumerateObject())
                list.Add(prop.Name);
        }
        return list;
    }

    private async Task<bool> VerifyCidExistsAsync(string cid)
    {
        // /api/v0/ls will resolve DAG roots; if it returns 200 we're good
        var rest = $"/api/v0/ls?arg={Uri.EscapeDataString(cid)}";
        using var res = await ApiProxyEndpoints.SendProxyApiRequest(rest, HttpFactory, Keys);
        return res.IsSuccessStatusCode;
    }

    private async Task FilesCpFromIpfsAsync(string cid, string destPath)
    {
        var from = $"/ipfs/{cid}";
        var rest = $"/api/v0/files/cp?arg={Uri.EscapeDataString(from)}&arg={Uri.EscapeDataString(destPath)}&parents=true";
        using var res = await ApiProxyEndpoints.SendProxyApiRequest(rest, HttpFactory, Keys);
        if (!res.IsSuccessStatusCode)
            throw new InvalidOperationException($"files/cp failed ({(int)res.StatusCode})");
    }

    private async Task FilesRmRecursiveAsync(string mfsPath)
    {
        mfsPath = IpfsGateway.NormalizeMfs(mfsPath);
        var rest = $"/api/v0/files/rm?arg={Uri.EscapeDataString(mfsPath)}&recursive=true";
        using var res = await ApiProxyEndpoints.SendProxyApiRequest(rest, HttpFactory, Keys);
        if (!res.IsSuccessStatusCode)
            throw new InvalidOperationException($"files/rm failed for '{mfsPath}' ({(int)res.StatusCode})");
    }

    private async Task PinAddRecursiveAsync(string cid)
    {
        var rest = $"/api/v0/pin/add?arg={Uri.EscapeDataString(cid)}&recursive=true";
        using var res = await ApiProxyEndpoints.SendProxyApiRequest(rest, HttpFactory, Keys);
        if (!res.IsSuccessStatusCode)
            throw new InvalidOperationException($"pin/add failed ({(int)res.StatusCode})");
    }

    private async Task PinRmRecursiveAsync(string cid)
    {
        var rest = $"/api/v0/pin/rm?arg={Uri.EscapeDataString(cid)}&recursive=true";
        using var res = await ApiProxyEndpoints.SendProxyApiRequest(rest, HttpFactory, Keys);
        if (!res.IsSuccessStatusCode)
            throw new InvalidOperationException($"pin/rm failed ({(int)res.StatusCode})");
    }

    private async Task<long?> TryMfsCumulativeSizeAsync(string mfsPath)
    {
        var rest = $"/api/v0/files/stat?arg={Uri.EscapeDataString(mfsPath)}";
        using var res = await ApiProxyEndpoints.SendProxyApiRequest(rest, HttpFactory, Keys);
        if (!res.IsSuccessStatusCode) return null;

        var root = await ReadLastJsonObjectAsync(res);
        if (root is null) return null;

        if (root.Value.TryGetProperty("CumulativeSize", out var cs) && TryGetInt64Flexible(cs, out var val))
            return val;

        if (root.Value.TryGetProperty("Size", out var sz) && TryGetInt64Flexible(sz, out var sVal))
            return sVal;

        return null;
    }

    private async Task<long?> TryDagSizeAsync(string cid)
    {
        var rest = $"/api/v0/dag/stat?arg={Uri.EscapeDataString(cid)}";
        using var res = await ApiProxyEndpoints.SendProxyApiRequest(rest, HttpFactory, Keys);
        if (!res.IsSuccessStatusCode) return null;

        var root = await ReadLastJsonObjectAsync(res);
        if (root is null) return null;

        if (root.Value.TryGetProperty("Size", out var sz) && TryGetInt64Flexible(sz, out var size))
            return size;

        return null;
    }

    private async Task<long?> TryBlockSizeAsync(string cid)
    {
        var rest = $"/api/v0/block/stat?arg={Uri.EscapeDataString(cid)}";
        using var res = await ApiProxyEndpoints.SendProxyApiRequest(rest, HttpFactory, Keys);
        if (!res.IsSuccessStatusCode) return null;

        var root = await ReadLastJsonObjectAsync(res);
        if (root is null) return null;

        if (root.Value.TryGetProperty("Size", out var sz) && TryGetInt64Flexible(sz, out var size))
            return size;

        return null;
    }


    private static async Task<JsonElement?> ReadLastJsonObjectAsync(HttpResponseMessage res)
    {
        var text = await res.Content.ReadAsStringAsync();
        if (string.IsNullOrWhiteSpace(text)) return null;

        // Fast path: single JSON value
        try
        {
            using var doc = JsonDocument.Parse(text);
            return doc.RootElement.Clone();
        }
        catch
        {
            // Fall through for NDJSON / concatenated JSON objects
        }

        // NDJSON: take the LAST line that is a valid JSON object
        foreach (var line in text.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries).Reverse())
        {
            var trimmed = line.Trim();
            if (!trimmed.StartsWith("{") || !trimmed.EndsWith("}")) continue;
            try
            {
                using var doc = JsonDocument.Parse(trimmed);
                return doc.RootElement.Clone();
            }
            catch { /* try previous line */ }
        }

        // Last-ditch: carve the last {...} block
        var lastOpen = text.LastIndexOf('{');
        var lastClose = text.LastIndexOf('}');
        if (lastOpen >= 0 && lastClose > lastOpen)
        {
            var candidate = text.Substring(lastOpen, lastClose - lastOpen + 1).Trim();
            try
            {
                using var doc = JsonDocument.Parse(candidate);
                return doc.RootElement.Clone();
            }
            catch { }
        }
        return null;
    }

    private static bool TryGetInt64Flexible(JsonElement el, out long value)
    {
        if (el.ValueKind == JsonValueKind.Number && el.TryGetInt64(out value)) return true;
        if (el.ValueKind == JsonValueKind.String && long.TryParse(el.GetString(), out value)) return true;
        value = 0;
        return false;
    }


    private async Task Copy(string text)
    {
        await JS.InvokeVoidAsync("navigator.clipboard.writeText", text);
        Snackbar.Add("Copied to clipboard", Severity.Info);
    }

    private sealed class PinnedRow
    {
        public required string Cid { get; init; }
        public string? Name { get; init; }
        public string? MfsPath { get; init; }
        public bool IsManaged { get; init; }
        public bool IsProductionNonManaged { get; init; }
        public long? SizeBytes { get; init; }
        public bool CanDelete { get; init; }
        public string? DeleteDisabledReason { get; init; }
    }
    // Normalizes ANY cid (v0/v1) to v1 base32 using your proxy.
    // Caches results so we don't hammer the node while building indexes.
    private readonly Dictionary<string, string> _cidV1Cache = new(StringComparer.OrdinalIgnoreCase);

    private async Task<string> NormalizeCidV1Async(string cid)
    {
        if (string.IsNullOrWhiteSpace(cid)) return cid;
        if (_cidV1Cache.TryGetValue(cid, out var cached)) return cached;

        var rest = $"/api/v0/cid/format?arg={Uri.EscapeDataString(cid)}&v=1&b=base32";
        using var res = await ApiProxyEndpoints.SendProxyApiRequest(rest, HttpFactory, Keys);
        if (!res.IsSuccessStatusCode)
        {
            // Fallback: if format fails, keep the original (match best-effort)
            _cidV1Cache[cid] = cid;
            return cid;
        }
        var v = (await res.Content.ReadAsStringAsync()).Trim();
        _cidV1Cache[cid] = v;
        return v;
    }

    private sealed record MfsEntry(string Name, string Path, string CidV1);

    private async Task<Dictionary<string, MfsEntry>> BuildProductionCidIndexAsync()
    {
        var index = new Dictionary<string, MfsEntry>(StringComparer.OrdinalIgnoreCase);

        // 1) /production (immediate)
        var prodChildren = await ListMfsChildrenAsync(ProductionRoot);
        foreach (var kv in prodChildren)
        {
            var name = kv.Key;
            var (cid, path) = kv.Value;
            var cidV1 = await NormalizeCidV1Async(cid);
            index[cidV1] = new MfsEntry(name, path, cidV1);
        }

        // 2) First-level directories beneath /production (e.g., /production/sites/*)
        // We only descend into children that are *directories*. files/ls doesn't always mark type consistently,
        // so we just try listing their children; if it fails, we skip.
        foreach (var (_, child) in prodChildren)
        {
            // child.Path is /production/<something>
            var subChildren = await ListMfsChildrenAsync(child.Path);
            foreach (var skv in subChildren)
            {
                var sname = skv.Key;
                var (scid, spath) = skv.Value;
                var scidV1 = await NormalizeCidV1Async(scid);
                // Prefer a specific match; don’t overwrite an existing key
                index.TryAdd(scidV1, new MfsEntry(sname, spath, scidV1));
            }
        }

        return index;
    }

}
