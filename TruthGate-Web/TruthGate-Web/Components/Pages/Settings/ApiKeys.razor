@page "/keys"
@using TruthGate_Web.Components.Pages.Settings.Shared
@using TruthGate_Web.Models
@using TruthGate_Web.Utils
@inject IConfigService ConfigSvc
@inject IDialogService Dialogs
@inject ISnackbar Snackbar
@rendermode InteractiveServer

<MudContainer Class="py-3" MaxWidth="MudBlazor.MaxWidth.Medium">
<div class="flex items-center justify-between mb-4">
    <MudText Typo="Typo.h5">API Keys</MudText>
    <br />
    <MudButton Variant="Variant.Filled" OnClick="AddKey" Color="Color.Primary"
    StartIcon="@Icons.Material.Filled.VpnKey">Add Key</MudButton>
</div>

<MudTable Items="_keys" Dense="true" Hover="true" Bordered="true">
    <HeaderContent>
        <MudTh>Name</MudTh>
        <MudTh>Hash (preview)</MudTh>
        <MudTh>Actions</MudTh>
    </HeaderContent>
    <RowTemplate>
        <MudTd DataLabel="Name">@context.Name</MudTd>
        <MudTd DataLabel="Hash">
            @ShortHash(context.KeyHashed)
        </MudTd>
        <MudTd>
            <MudButton Size="Size.Small"
                       Variant="Variant.Outlined"
                       Color="Color.Error"
                       OnClick="@(() => DeleteKey(context))"
                       StartIcon="@Icons.Material.Filled.DeleteForever">
                Delete
            </MudButton>
        </MudTd>
    </RowTemplate>
    <NoRecordsContent>
        <MudText>No API keys yet.</MudText>
    </NoRecordsContent>
</MudTable>
</MudContainer>
@code
{
    private List<ApiKey> _keys = new();

    protected override void OnInitialized() => LoadFromConfig();

    private void LoadFromConfig()
    {
        var cfg = ConfigSvc.Get();
        _keys = (cfg.ApiKeys ?? new List<ApiKey>())
            .OrderBy(k => k.Name, StringComparer.OrdinalIgnoreCase)
            .ToList();
        StateHasChanged();
    }

    private string ShortHash(string? h)
    {
        if (string.IsNullOrWhiteSpace(h)) return "(empty)";
        var t = h.Trim();
        return t.Length <= 12 ? t : $"{t.Substring(0, 6)}…{t.Substring(t.Length - 6)}";
    }

    private async Task AddKey()
    {
        // Pass existing names so dialog can pre-check uniqueness
        var p = new DialogParameters<AddApiKeyDialog>
        {
            { x => x.ExistingNames, _keys.Select(k => k.Name).ToList() }
        };

        var dialog = Dialogs.Show<AddApiKeyDialog>("Add API Key", p, new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true });
        var result = await dialog.Result;

        if (result.Canceled || result.Data is not AddApiKeyDialog.AddApiKeyResult r) return;

        // Final uniqueness check (server-side)
        if (_keys.Any(k => string.Equals(k.Name, r.Name, StringComparison.OrdinalIgnoreCase)))
        {
            Snackbar.Add($"A key named '{r.Name}' already exists.", Severity.Error);
            return;
        }

        await ConfigSvc.UpdateAsync(cfg =>
        {
            cfg.ApiKeys.Add(new ApiKey
                {
                    Name = r.Name,
                    KeyHashed = r.KeyHashed
                });
        });

        Snackbar.Add($"API key '{r.Name}' created.", Severity.Success);
        LoadFromConfig();
    }

    private async Task DeleteKey(ApiKey key)
    {
        var p = new DialogParameters<ConfirmDeleteDialog>
        {
            { x => x.Message, $"Delete API key '{key.Name}'?" }
        };

        var dialog = Dialogs.Show<ConfirmDeleteDialog>("Confirm Delete", p);
        var result = await dialog.Result;

        if (result.Canceled || result.Data is not bool yes || !yes) return;

        await ConfigSvc.UpdateAsync(cfg =>
        {
            var list = cfg.ApiKeys ?? new List<ApiKey>();
            var idx = list.FindIndex(k => string.Equals(k.Name, key.Name, StringComparison.OrdinalIgnoreCase));
            if (idx >= 0) list.RemoveAt(idx);
        });

        Snackbar.Add($"API key '{key.Name}' deleted.", Severity.Success);
        LoadFromConfig();
    }
}