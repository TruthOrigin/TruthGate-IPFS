@page "/domains"
@using System.Globalization
@using System.Text.RegularExpressions
@using MudBlazor
@using TruthGate_Web.Components.Pages.Settings.Shared
@using TruthGate_Web.Models
@using TruthGate_Web.Utils
@inject IConfigService ConfigSvc
@inject IDialogService Dialogs
@inject ISnackbar Snackbar
@rendermode InteractiveServer
@inject IJSRuntime JS
@inject IHttpClientFactory HttpFactory
@inject IApiKeyProvider Keys

<MudContainer Class="py-3" MaxWidth="MudBlazor.MaxWidth.Medium">
    <div class="flex items-center justify-between mb-4">
        <MudText Typo="Typo.h3">Domains</MudText>
        <br />

        <MudStack Spacing="2" Row="true">
            <MudButton Variant="Variant.Filled"
            Color="Color.Primary"
            StartIcon="@Icons.Material.Filled.DomainAdd"
            OnClick="AddDomain">
                Add Domain
            </MudButton>

            <MudButton Variant="Variant.Filled"
            Color="Color.Secondary"
            StartIcon="@Icons.Material.Filled.UploadFile"
            OnClick="ImportDomain">Import Domain</MudButton>
        </MudStack>
    </div>

    <MudTable Items="_domains" Dense="true" Hover="true" Bordered="true">
        <HeaderContent>
            <MudTh>Domain</MudTh>
            <MudTh>Flags</MudTh>
            <MudTh>Actions</MudTh>
        </HeaderContent>

        <RowTemplate>
            <MudTd DataLabel="Domain">
                @context.Domain
                @if (!string.IsNullOrWhiteSpace(context.RedirectUrl))
                {
                    <MudText Typo="Typo.caption" Class="truncate-text" Title="@context.RedirectUrl">
                        @{
                            var u = context.RedirectUrl ?? string.Empty;
                        }
                        @($"Redirect: {(u.Length > 25 ? $"{u.Substring(0, 23)}..." : u)}")
                    </MudText>
                }
                else if (!string.IsNullOrWhiteSpace(_wildcardHost) &&
                (!string.IsNullOrWhiteSpace(context.IpnsPeerId) || !string.IsNullOrWhiteSpace(context.IpnsKeyName)))
                {

                    <MudStack Row="true" Spacing="1" Class="mt-1">
                        <MudTooltip Text="@($"{GetLabel(context)}.{_wildcardHost}")">
                            <MudChip T="string" Color="Color.Primary" Variant="Variant.Outlined" StartIcon="@Icons.Material.Filled.Link">
                                @($"{GetIpnsHost(context, useShort: true)}")
                            </MudChip>
                        </MudTooltip>

                        <MudIconButton Icon="@Icons.Material.Filled.ContentCopy"
                        Size="Size.Small"
                                       OnClick="@(() => CopyToClipboard($"{GetLabel(context)}.{_wildcardHost}"))" />
                    </MudStack>
                }
            </MudTd>
            <MudTd DataLabel="Use SSL">
                @if (ToBool(context.UseSSL))
                {
                    <MudChip T="string" Color="Color.Primary" Variant="Variant.Filled" Icon="@Icons.Material.Filled.Lock">SSL Enabled</MudChip>
                }
                else
                {
                    <MudChip T="string" Color="Color.Default" Variant="Variant.Outlined" Icon="@Icons.Material.Filled.LockOpen">SSL Disabled</MudChip>
                }

                @if (!string.IsNullOrWhiteSpace(context.IpnsPeerId))
                {
                    <MudStack Row="true" Spacing="1" Class="mb-2">
                        @*    <MudChip T="string" Variant="Variant.Outlined" StartIcon="@Icons.Material.Filled.VpnKey">
                            @context.IpnsKeyName
                        </MudChip> *@
                        <MudTooltip Text="@context.IpnsPeerId">
                            <MudChip T="string" Color="Color.Primary" Variant="Variant.Outlined" StartIcon="@Icons.Material.Filled.Fingerprint">
                                IPNS: @Short(context.IpnsPeerId)
                            </MudChip>
                        </MudTooltip>
                        <MudIconButton Icon="@Icons.Material.Filled.ContentCopy" Size="Size.Small"
                        OnClick="@(() => CopyToClipboard(context.IpnsPeerId))" />
                    </MudStack>
                }

            </MudTd>
            <MudTd>
                @if (string.IsNullOrWhiteSpace(context.RedirectUrl))
                {

                    <MudButton Class="mr-2" Size="Size.Small" Variant="Variant.Outlined" StartIcon="@Icons.Material.Filled.CloudUpload"
                    OnClick="@(() => PublishDomain(context))">Publish</MudButton>
                    <MudButton Class="mr-2" Size="Size.Small" Variant="Variant.Outlined" StartIcon="@Icons.Material.Filled.Download"
                    OnClick="@(() => BackupDomain(context))">Backup</MudButton>
                }
                <MudButton Size="Size.Small"
                Variant="Variant.Outlined"
                StartIcon="@Icons.Material.Filled.Edit"
                Class="mr-2"
                OnClick="@(() => EditDomain(context))">
                    Edit
                </MudButton>
                <MudButton Size="Size.Small"
                Variant="Variant.Outlined"
                Color="Color.Error"
                StartIcon="@Icons.Material.Filled.DeleteForever"
                OnClick="@(() => DeleteDomain(context))">
                    Delete
                </MudButton>
            </MudTd>
        </RowTemplate>

        <NoRecordsContent>
            <MudText>No domains yet.</MudText>
        </NoRecordsContent>
    </MudTable>
</MudContainer>

@code
{
    private string GetLabel(EdgeDomain context)
    {
        return !string.IsNullOrWhiteSpace(context.IpnsPeerId)
                        ? context.IpnsPeerId!
                        : context.IpnsKeyName!;
    }

    private string? _wildcardHost; // from Config
    private List<EdgeDomain> _domains = new();

    private string GetIpnsHost(EdgeDomain context, bool useShort = false)
    {
        // Prefer PeerId; fallback to KeyName
        var label = !string.IsNullOrWhiteSpace(context.IpnsPeerId)
            ? context.IpnsPeerId!
            : context.IpnsKeyName!;

        if (useShort)
            return $"{ShortMid(label)}.{_wildcardHost}";
        else
            return $"{label}.{_wildcardHost}";
    }


    private async Task PublishDomain(EdgeDomain d)
    {
        var parms = new DialogParameters<PublishDialog> { { x => x.Domain, d.Domain } };
        var dlg = Dialogs.Show<PublishDialog>($"Publish: {d.Domain}", parms,
            new DialogOptions { FullWidth = true, MaxWidth = MaxWidth.Large, CloseButton = true });

        await dlg.Result;

        // Reload once
        LoadFromConfig();

        // Optional: light polling for a short window so the key appears once the queue finishes
        _ = Task.Run(async () =>
        {
            var until = DateTime.UtcNow.AddSeconds(30);
            while (DateTime.UtcNow < until)
            {
                await InvokeAsync(LoadFromConfig);
                if (_domains.Any(x => x.Domain.Equals(d.Domain, StringComparison.OrdinalIgnoreCase)
                                      && !string.IsNullOrWhiteSpace(x.IpnsPeerId)))
                    break;

                await Task.Delay(1500);
            }
        });
    }

    private static string Short(string s)
    => string.IsNullOrWhiteSpace(s) ? "—" : (s.Length <= 7 ? s : $"{s[..3]}…{s[^2..]}");


    private async Task CopyToClipboard(string s)
        => await JS.InvokeVoidAsync("navigator.clipboard.writeText", s);
    private async Task BackupDomain(EdgeDomain d)
    {
        var pass = await PromptAsync("Backup passphrase", "Enter a passphrase to encrypt your IPNS key export.");
        if (string.IsNullOrWhiteSpace(pass)) return;

        var url = $"/api/domains/{Uri.EscapeDataString(d.Domain)}/backup?passphrase={Uri.EscapeDataString(pass)}";
        await JS.InvokeVoidAsync("open", url, "_blank"); // save-as
    }

    private async Task ImportDomain()
    {
        var parms = new DialogParameters<ImportDomainDialog>();
        var dlg = Dialogs.Show<ImportDomainDialog>("Import Domain Backup", parms,
            new DialogOptions { FullWidth = true, MaxWidth = MaxWidth.Medium, CloseButton = true });
        await dlg.Result;
    }

    private async Task<string?> PromptAsync(string title, string message)
    {
        var p = new DialogParameters<SimplePromptDialog> { { x => x.Message, message } };
        var dlg = Dialogs.Show<SimplePromptDialog>(title, p);
        var res = await dlg.Result;
        return res.Canceled ? null : (res.Data as string);
    }


    protected override void OnInitialized()
    {
        LoadFromConfig();
    }

    private void LoadFromConfig()
    {
        var cfg = ConfigSvc.Get();

        _wildcardHost = cfg?.IpnsWildCardSubDomain?.WildCardSubDomain?.Trim();

        _domains = (cfg.Domains ?? new List<EdgeDomain>())
            .Where(d => !string.IsNullOrWhiteSpace(d?.Domain))
            .OrderBy(d => d.Domain, StringComparer.OrdinalIgnoreCase)
            .Select(d => new EdgeDomain
                {
                    Domain = (d.Domain ?? string.Empty).Trim(),
                    UseSSL = (d.UseSSL ?? string.Empty).Trim(),
                    RedirectUrl = (d.RedirectUrl ?? string.Empty).Trim(),
                    IpnsKeyName = d.IpnsKeyName?.Trim(),
                    IpnsPeerId = d.IpnsPeerId?.Trim(),
                    LastPublishedCid = d.LastPublishedCid?.Trim(),
                    LastPublishedAt = d.LastPublishedAt
                })
            .ToList();

        StateHasChanged();
    }
    private static string ShortMid(string s, int head = 6, int tail = 4)
       => string.IsNullOrWhiteSpace(s) || s.Length <= head + tail + 1 ? s : $"{s[..head]}…{s[^tail..]}";
    private async Task AddDomain()
    {
        var dialog = Dialogs.Show<AddOrEditDomainDialog>("Add Domain");
        var result = await dialog.Result;

        if (result.Canceled || result.Data is not AddOrEditDomainDialog.DomainResult r) return;

        // Normalize + validate
        var normalized = NormalizeDomain(r.Domain);
        if (string.IsNullOrEmpty(normalized))
        {
            Snackbar.Add("Please provide a valid domain.", Severity.Error);
            return;
        }

        // Uniqueness (case-insensitive)
        if (_domains.Any(d => string.Equals(d.Domain, normalized, StringComparison.OrdinalIgnoreCase)))
        {
            Snackbar.Add($"Domain '{normalized}' already exists.", Severity.Error);
            return;
        }

        await ConfigSvc.UpdateAsync(cfg =>
        {
            cfg.Domains ??= new List<EdgeDomain>();
            cfg.Domains.Add(new EdgeDomain
                {
                    Domain = normalized,
                    UseSSL = r.UseSSL ? "true" : "false",
                    RedirectUrl = r.RedirectUrl?.Trim(),
                });
        });

        Snackbar.Add($"Domain '{normalized}' added.", Severity.Success);
        LoadFromConfig();
    }

    private async Task EditDomain(EdgeDomain domain)
    {
        var parameters = new DialogParameters<AddOrEditDomainDialog>
        {
            { x => x.InitialDomain, domain.Domain },
            { x => x.InitialRedirectUrl, domain.RedirectUrl },
            { x => x.InitialUseSSL, ToBool(domain.UseSSL) },
            { x => x.IsEdit, true }
        };

        var dialog = Dialogs.Show<AddOrEditDomainDialog>($"Edit Domain: {domain.Domain}", parameters);
        var result = await dialog.Result;

        if (result.Canceled || result.Data is not AddOrEditDomainDialog.DomainResult r) return;

        var normalized = NormalizeDomain(r.Domain);
        if (string.IsNullOrEmpty(normalized))
        {
            Snackbar.Add("Please provide a valid domain.", Severity.Error);
            return;
        }

        // If the name changed, ensure new name isn't taken
        bool changed = !string.Equals(domain.Domain, normalized, StringComparison.OrdinalIgnoreCase);
        if (changed && _domains.Any(d => string.Equals(d.Domain, normalized, StringComparison.OrdinalIgnoreCase)))
        {
            Snackbar.Add($"Another domain with the name '{normalized}' already exists.", Severity.Error);
            return;
        }

        await ConfigSvc.UpdateAsync(cfg =>
        {
            var list = cfg.Domains ??= new List<EdgeDomain>();
            var target = list.FirstOrDefault(d => string.Equals(d.Domain, domain.Domain, StringComparison.OrdinalIgnoreCase));
            if (target is not null)
            {
                target.Domain = normalized;
                target.UseSSL = r.UseSSL ? "true" : "false";
                target.RedirectUrl = r.RedirectUrl?.Trim();
            }
        });

        Snackbar.Add($"Domain updated to '{normalized}'.", Severity.Success);
        LoadFromConfig();
    }

    private async Task DeleteDomain(EdgeDomain domain)
    {
        var parameters = new DialogParameters<ConfirmDeleteDialog>
    {
        { x => x.Message, $"Delete domain '{domain.Domain}'?\n\nThis will remove its config entry, IPNS key, pins, and MFS folders." }
    };

        var dialog = Dialogs.Show<ConfirmDeleteDialog>("Confirm Delete", parameters);
        var result = await dialog.Result;
        if (result.Canceled || result.Data is not bool confirmed || !confirmed) return;

        try
        {
            // 0) Load current config entry to discover leafs/keys
            var cfg = ConfigSvc.Get();
            var ed = (cfg.Domains ?? new()).FirstOrDefault(d =>
                d.Domain.Equals(domain.Domain, StringComparison.OrdinalIgnoreCase));
            if (ed is null)
            {
                // If already gone in config, just refresh the UI
                Snackbar.Add($"Domain '{domain.Domain}' not found in config.", Severity.Info);
                LoadFromConfig();
                return;
            }

            // 1) Compute leaves & paths (same defaults used during publish)
            var siteLeaf = string.IsNullOrWhiteSpace(ed.SiteFolderLeaf)
                ? (IpfsGateway.ToSafeLeaf(ed.Domain) ?? ed.Domain.ToLowerInvariant())
                : ed.SiteFolderLeaf;

            var tgpLeaf = string.IsNullOrWhiteSpace(ed.TgpFolderLeaf)
                ? $"tgp-{siteLeaf.Replace('.', '-')}"
                : ed.TgpFolderLeaf;

            var sitePath = IpfsGateway.NormalizeMfs($"/production/sites/{siteLeaf}");
            var tgpPath = IpfsGateway.NormalizeMfs($"/production/pinned/{tgpLeaf}");

            // 2) Resolve current CIDs (best-effort)
            var siteCid = await IpfsAdmin.FilesStatHashAsync(sitePath, HttpFactory, Keys);
            var tgpCid = await IpfsAdmin.FilesStatHashAsync(tgpPath, HttpFactory, Keys);

            // 3) Unpin (best-effort) + invalidate CID caches
            async Task UnpinIfAsync(string? cid)
            {
                if (string.IsNullOrWhiteSpace(cid)) return;
                await IpfsAdmin.PinRmRecursiveIfAsync(cid!, HttpFactory, Keys);
                IpfsAdmin.InvalidateCid(cid!);
            }
            await UnpinIfAsync(siteCid);
            await UnpinIfAsync(tgpCid);
            await UnpinIfAsync(ed.LastPublishedCid);

            // 4) Remove MFS folders (best-effort) + invalidate MFS caches
            await IpfsAdmin.FilesRmTreeAsync(sitePath, HttpFactory, Keys);
            await IpfsAdmin.FilesRmTreeAsync(tgpPath, HttpFactory, Keys);

            // 5) Remove the IPNS key (best-effort)
            if (!string.IsNullOrWhiteSpace(ed.IpnsKeyName))
                await IpfsAdmin.KeyRemoveIfExistsAsync(ed.IpnsKeyName!, HttpFactory, Keys);

            // 6) Remove from config and persist
            await ConfigSvc.UpdateAsync(c =>
            {
                c.Domains ??= new List<EdgeDomain>();
                var idx = c.Domains.FindIndex(d => d.Domain.Equals(domain.Domain, StringComparison.OrdinalIgnoreCase));
                if (idx >= 0) c.Domains.RemoveAt(idx);
            });

            Snackbar.Add($"Domain '{domain.Domain}' deleted.", Severity.Success);
            LoadFromConfig();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Delete failed: {ex.Message}", Severity.Error);
        }
    }


    private static bool ToBool(string? value)
        => bool.TryParse(value?.Trim(), out var b) ? b : false;

    /// <summary>
    /// Trim, lower, strip scheme/path/port, normalize IDN -> ASCII, remove trailing dot.
    /// Returns empty string if not a plausible hostname.
    /// </summary>
    private static string NormalizeDomain(string? input)
    {
        if (string.IsNullOrWhiteSpace(input)) return string.Empty;

        var s = input.Trim();

        // If someone pasted with scheme, try to parse and extract host
        if (s.StartsWith("http://", StringComparison.OrdinalIgnoreCase) ||
            s.StartsWith("https://", StringComparison.OrdinalIgnoreCase))
        {
            if (Uri.TryCreate(s, UriKind.Absolute, out var uri) && !string.IsNullOrEmpty(uri.Host))
                s = uri.Host;
        }

        // If there's a slash, take the host-like part before it
        var slash = s.IndexOf('/');
        if (slash >= 0) s = s.Substring(0, slash);

        // Drop any surrounding whitespace and lower
        s = s.Trim().TrimEnd('.').ToLowerInvariant();

        // Strip obvious port if present (e.g., example.com:8443)
        // (We avoid IPv6 complexity because domains shouldn't be IPv6 literals)
        var colon = s.IndexOf(':');
        if (colon >= 0) s = s.Substring(0, colon);

        // Basic allowed chars check (ASCII hostname)
        if (!Regex.IsMatch(s, @"^[a-z0-9.-]+$")) return string.Empty;
        if (s.StartsWith("-") || s.EndsWith("-")) return string.Empty;
        if (s.Contains("..")) return string.Empty;

        // Convert IDN to ASCII (punycode) if devs type unicode
        try
        {
            var idn = new IdnMapping();
            s = idn.GetAscii(s);
        }
        catch
        {
            return string.Empty;
        }

        // Quick sanity: must contain at least one dot and a non-empty label on each side
        var parts = s.Split('.', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
        if (parts.Length < 2 || parts.Any(p => p.Length == 0)) return string.Empty;

        return s;
    }
}
